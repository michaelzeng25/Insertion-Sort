1, Type of Triangle

select case
       when A=B and a=c then 'Equilateral'
       when (A=b and a+b>c) or (a=c and a+c>b)  or (b=c and b+c>a)  then 'Isosceles'
       when a+b<=c or a+c<=b or b+c<=a then 'Not A Triangle'
       else 'Scalene '
       end 
from TRIANGLES  

or perhaps something like this:

delimiter //
create function myf(a int, b int, c int) returns varchar(55) deterministic
begin
declare name varchar(55);
if a=b and a=c then set name='Equilateral';
elseif (a=b and a+b>c) or (a=c and a+c>b)  or (b=c and b+c>a)  then set name= 'Isosceles';
elseif a+b<=c or a+c<=b or b+c<=a then set name='Not A Triangle';
else set name='Scalene';
end if;
return(name);
end//
delimiter ;

select myf(a,b,c) from TRIANGLES;




2, The PADS

select a.* 
from
(
select concat(name, '(',left(occupation,1),')') 
from OCCUPATIONS order by name limit 10000
)a

union

select b.* 
from
(
select concat('There are a total of ',a.cnt,' ',lower(a.occupation),'s.') 
from  (select  occupation, count(occupation)as cnt from OCCUPATIONS group by occupation order by count(occupation) , occupation)a
)b;

Without using limit in the first query, the order by will have no affect.
read here: https://dev.mysql.com/doc/refman/5.7/en/union.html




3, Occupation

select min(b.Doctor), min(b.Professor),min(b.Singer),min(b.Actor)
from
(
select 
case 
when Occupation ='Doctor' then (@a:=@a+1)
when Occupation ='Professor' then (@b:=@b+1) 
when Occupation ='Singer' then (@c:=@c+1)
when Occupation ='Actor' then (@d:=@d+1)
end as index1,
case 
when Occupation ='Doctor' then name 
end as Doctor,
case 
when Occupation ='Professor' then name 
end as Professor,
case 
when Occupation ='Singer' then name 
end as Singer,
case 
when Occupation ='Actor' then name 
end as Actor
from 
OCCUPATIONS 
join(select @a:=0, @b:=0,@c:=0,@d:=0 ) w
order by name
)b 
group by index1;

a very good practice in using variables.



4, Binary tree node

select n, 'Leaf' from BST where n not in (select p from BST where p is not null)
union
select n, 'Inner' from BST where n in (select p from BST) and p is not null
union
select n, 'Root' from BST where p is null
order by n

or (inspired by other coders)

SELECT N, 
case 
when p is null then 'Root'
when (SELECT COUNT(*) FROM BST WHERE P=B.N)>0 then 'Inner'
else 'Leaf'
end
FROM BST B 
ORDER BY N;


/*
The code is pretty obvious.
all the leaf node will not be in the 'p' column.
and in the 'p' column, the one that is null is the root, and the rests are inner.

"SELECT COUNT(*) FROM BST WHERE P=B.N)>0 " - leaf nodes only exist in n not in p.

*/
